boolean lineIsCorrect(boolean[] line) {
  /// State: 0->0; 1->1; 2->00; 3->11; 4->.
  char state = 4, _0 = 0, _1 = 0;
  for (int i = 0; i < line.length; ++i) {
    if (line[i]) {
      _1++;
    } else {
      _0++;
    }
    /// If neutral state or different state
    if (state == 4 || ((state & 1) != 0) != line[i])
        state = (char) (line[i] ? 1 : 0);
    else if ((state += 2) > 3) {
      /// Go from 0 to 2 or 1 to 3
      return false;
    }
  }
  return _0 == _1;
}

/// long -> 64bits
boolean lineIsCorrect(long line) {
  /// State: 0->0; 1->1; 2->00; 3->11; 4->.
  char state = 4, _0 = 0, _1 = 0;
  for (int i = 0; i < line.length; ++i) {
    if (line[i]) {
      _1++;
    } else {
      _0++;
    }
    /// If neutral state or different state
    if (state == 4 || ((state & 1) != 0) != line[i])
        state = (char) (line[i] ? 1 : 0);
    else if ((state += 2) > 3) {
      /// Go from 0 to 2 or 1 to 3
      return false;
    }
  }
  return _0 == _1;
}

boolean[] newLine(int number, int len) {
  boolean[] line = new boolean[len];
  for (int i = len - 1; i > -1; --i) {
    line[i] = number % 2 != 0;
    number >>= 1;
  }
  return line;
}

ArrayList<boolean[]> getAllCorrectOnes(int length) {
  ArrayList<boolean[]> output = new ArrayList<boolean[]>();
  for (int i = 0; i < pow(2, length); ++i) {
    boolean[] line = newLine(i, length);
    if (lineIsCorrect(line))
      output.add(line);
  }
  return output;
}

/// Will return false if there is a value too big
boolean n(int[] streak, ArrayList<Integer> _list) {
  boolean output = true;
  for (int i = 0; i < streak.length; ++i) {
    if (streak[i] == 0) {
      streak[i] = (_list.get(i) == 0 ? -1 : 1);
    } else if (streak[i] < 0) {
      streak[i] = (_list.get(i) == 0 ? streak[i] - 1 : 0);
    } else {
      streak[i] = (_list.get(i) == 0 ? 0 : streak[i] + 1);
    }
    if (abs(streak[i]) > 2) {
      output =  false;
    }
  }
  return output;
}

void setup() {
  int _gridSize = 8;

  ArrayList<boolean[][]> matrixes;
  matrixes = new ArrayList<boolean[][]>();

  final ArrayList<boolean[]> _everyPossibilities = getAllCorrectOnes(_gridSize);

  for (final boolean[] _reference : _everyPossibilities) {
    //////////////////////////////////////////////////////////////////////
    ArrayList<ArrayList<boolean[]>> possibilities = new ArrayList<ArrayList<boolean[]>>();
    for (boolean i : _reference) {
      possibilities.add(new ArrayList());
      for (final boolean[] j : _everyPossibilities) {
        if (i == j[0]) {
          possibilities.get(possibilities.size() - 1).add(j);
        }
      }
    }
    //////////////////////////////////////////////////////////////////////
    f(possibilities, matrixes, _gridSize);
    //////////////////////////////////////////////////////////////////////
  } 
  println(matrixes, _everyPossibilities.size());
}

void f(
  final ArrayList<ArrayList<boolean[]>> possibilities, 
  ArrayList<boolean[][]> matrixes, 
  boolean[][] partial, 
  final char[] _state, 
  final int _gridSize,
  final int length,
  ArrayList<Integer> indexes) {

  /// Streaks: + for 1 and - for 0
  /// Check streaks and divide

  if (length < _gridSize) {
    for (int _next_index = 0; _next_index < possibilities.get(length).size(); ++_next_index) {
      boolean[] _next = possibilities.get(length).get(_next_index);
      char[] _new_state = new char[_gridSize];
      boolean var = true;/// Wether 3 streaks
      for (int i = 0; i < _gridSize; ++i) {
        /// If neutral state or different state
        if (_state[i] == 4 || ((_state[i] & 1) != 0) != _next[i])
          _new_state[i] = (char) (_next[i] ? 1 : 0);
        else if ((_new_state[i] = (char) (_state[i] + 2)) > 3) {
          /// Go from 0 to 2 or 1 to 3
          var = false;
        }
      }
      if (var && !indexes.contains(_next_index)) {
        partial[length]  = _next;
        f(possibilities, matrixes, partial, _state, _gridSize, length + 1, indexes);
      }
    }
  } else {
    /// frequency is for ArrayList
    ArrayList<boolean[]> columns = new ArrayList<boolean[]>();
    for (int i = 0; i < _gridSize; ++i) {
      columns.add(new boolean[_gridSize]);
    }
    for (int i = 0; i < _gridSize; ++i) {
      for (int j = 0; j < _gridSize; ++j) {
        columns.get(j)[i] = partial[i][j];
      }
    }
    boolean cool = true;
    for (int i = 0; i < _gridSize; ++i) {
      if (!lineIsCorrect(columns.get(i))) {
        cool = false;
      }
    }
    for (int i = 0; i < _gridSize; ++i) {
      if (java.util.Collections.frequency(columns, columns.get(i)) > 1) {
        cool = false;
      }
    }
    if (cool) {
      println(matrixes.size());

      java.io.FileWriter f = null;
      try {
        f = new java.io.FileWriter("c:\\x\\" + matrixes.size() + ".txt");
        f.write(_gridSize + " // Autogenerated\n");
        for (boolean[]l : partial) {
          for (boolean i : l) {
            f.write(i ? "1" : "0");
          }
          f.write("\n");
        }
        f.flush();
        f.close();
      }
      catch(IOException e) {
        if (f != null) {
          try {
            f.close();
          }
          catch(IOException g) {
          }
        }
      }
      matrixes.add(partial);
    }
  }
}

void f(ArrayList<ArrayList<boolean[]>> possibilities, ArrayList<boolean[][]> matrixes, int _gridSize) {
  char[] states = new char[_gridSize];
  for (int i = 0; i< states.length; ++i) {
    states[i] = 4;
  }
  f(possibilities, matrixes, new boolean[_gridSize][_gridSize], states, _gridSize, 0, new ArrayList<Integer>(_gridSize));
}