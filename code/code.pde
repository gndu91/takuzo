boolean lineIsCorrect(ArrayList<Integer> line) {
  if (java.util.Collections.frequency(line, 0) != java.util.Collections.frequency(line, 1)) {
    return false;
  }
  int _0 = 0, _1 = 0;
  for (int i = 0; i < line.size(); ++i) {
    if (line.get(i) == 0) {
      _0++;
      _1 = 0;
      if (_0 > 2) {
        return false;
      }
    } else {
      _1++;
      _0 = 0;
      if (_1 > 2) {
        return false;
      }
    }
  }
  return true;
}

ArrayList<Integer> newLine(int number, int len) {

  ArrayList<Integer> line = new ArrayList<Integer>(len);


  for (int i = len - 1; i > -1; --i) {
    line.add(0);
  }

  for (int i = len - 1; i > -1; --i) {
    line.set(i, number % 2);
    number >>= 1;
  }
  return line;
}

ArrayList<ArrayList<Integer>> getAllCorrectOnes(int length) {
  ArrayList<ArrayList<Integer>> output = new ArrayList<ArrayList<Integer>>();

  for (int i = 0; i < pow(2, length); ++i) {
    ArrayList<Integer> line = newLine(i, length);
    if (lineIsCorrect(line)) {
      output.add(line);
    }
  }

  return output;
}

/// Will return false if there is a value too big
boolean n(int[] streak, ArrayList<Integer> _list) {
  boolean output = true;
  for (int i = 0; i < streak.length; ++i) {
    if (streak[i] == 0) {
      streak[i] = (_list.get(i) == 0 ? -1 : 1);
    } else if (streak[i] < 0) {
      streak[i] = (_list.get(i) == 0 ? streak[i] - 1 : 0);
    } else {
      streak[i] = (_list.get(i) == 0 ? 0 : streak[i] + 1);
    }
    if (abs(streak[i]) > 2) {
      output =  false;
    }
  }
  return output;
}

void setup() {
  int _gridSize = 8;

  ArrayList<ArrayList<ArrayList<Integer>>> matrixes;
  matrixes = new ArrayList<ArrayList<ArrayList<Integer>>>();

  final ArrayList<ArrayList<Integer>> _everyPossibilities = getAllCorrectOnes(_gridSize);

  for (final ArrayList<Integer>_reference : _everyPossibilities) {
    //////////////////////////////////////////////////////////////////////
    ArrayList<ArrayList<ArrayList<Integer>>> 
      possibilities = new ArrayList<ArrayList<ArrayList<Integer>>>();
    for (int i : _reference) {
      possibilities.add(new ArrayList());
      for (final ArrayList<Integer>j : _everyPossibilities) {
        if (i == j.get(0)) {
          possibilities.get(possibilities.size() - 1).add(j);
        }
      }
    }
    //////////////////////////////////////////////////////////////////////
    f(possibilities, matrixes, _gridSize);
    //////////////////////////////////////////////////////////////////////
  } 
  println(matrixes, _everyPossibilities.size());
}
void f(
  final ArrayList<ArrayList<ArrayList<Integer>>> possibilities, 
  ArrayList<ArrayList<ArrayList<Integer>>> matrixes, 
  final ArrayList<ArrayList<Integer>> partial, 
  final int[] _0_streaks, 
  final int[] _1_streaks, 
  final int _gridSize) {

  /// Streaks: + for 1 and - for 0
  /// Check streaks and divide

  if (partial.size() < _gridSize) {
    for (ArrayList<Integer> _next : possibilities.get(partial.size())) {
      int[] __0_streaks = new int[_gridSize], __1_streaks = new int[_gridSize]; 
      boolean var = true;/// Wether 3 streaks
      for (int i = 0; i < _gridSize; ++i) {
        if (_next.get(i) == 0) {
          __0_streaks[i] = _0_streaks[i] + 1;
          __1_streaks[i] = 0;
          var = __0_streaks[i] < 3;
        } else {
          __1_streaks[i] = _1_streaks[i] + 1;
          __0_streaks[i] = 0;
          var = __1_streaks[i] < 3;
        }
      }
      if (var && !partial.contains(_next)) {
        ArrayList<ArrayList<Integer>> _partial = new ArrayList(partial);
        _partial.add(_next);
        f(possibilities, matrixes, _partial, __0_streaks, __1_streaks, _gridSize);
      }
    }
  } else {
    ArrayList<ArrayList<Integer>> columns = new ArrayList<ArrayList<Integer>>();
    for (int i = 0; i < _gridSize; ++i) {
      columns.add(new ArrayList<Integer>());
      for (int j = 0; j < _gridSize; ++j) {
        columns.get(i).add(0);
      }
    }
    for (int i = 0; i < _gridSize; ++i) {
      for (int j = 0; j < _gridSize; ++j) {
        columns.get(j).set(i, partial.get(i).get(j));
      }
    }
    boolean cool = true;
    for (int i = 0; i < _gridSize; ++i) {
      if (!lineIsCorrect(columns.get(i))) {
        cool = false;
      }
    }
    for(int i = 0; i < _gridSize; ++i) {
      if(java.util.Collections.frequency(columns, columns.get(i)) > 1) {
        cool = false;
      }
    }
    if (cool) {
      println(matrixes.size());

      java.io.FileWriter f = null;
      try {
        f = new java.io.FileWriter("i:\\x\\" + matrixes.size() + ".txt");
        f.write(_gridSize + " // Autogenerated\n");
        for (ArrayList<Integer>l : partial) {
          for (Integer i : l) {
            f.write(str(i));
          }
          f.write("\n");
        }
        f.flush();
        f.close();
      }
      catch(IOException e) {
        if (f != null) {
          try {
            f.close();
          }
          catch(IOException g) {
          }
        }
      }
      matrixes.add(partial);
    }
  }
}
void f(ArrayList<ArrayList<ArrayList<Integer>>> possibilities, 
  ArrayList<ArrayList<ArrayList<Integer>>> matrixes, int _gridSize) {
  f(possibilities, matrixes, new ArrayList<ArrayList<Integer>>(),
    new int[_gridSize], new int[_gridSize], _gridSize);
}