correctLine = lambda l:l.count('0') == l.count('1') and not '000' in l and not '111' in l
everyPossibilities = lambda n:list(filter(correctLine, map(lambda i:bin(i)[2:].zfill(n), range(2**n))))

_gridSize = 8

_everyPossibilities = everyPossibilities(_gridSize)
# def getMatrix():

import os

_ = os.system('cls')
# Update streak
def n(streak, j):
 if not streak:
  return -1 if j == '0' else 1
 if streak < 0:
  if j == '1':return 0
  else:return streak - 1
 else:
  if j == '0':return streak + 1
  else:return 0
  

for _reference in _everyPossibilities:
 possibilities = [[j for j in _everyPossibilities if j[0] == i[0]] for i in _reference]
 def f(partial, streak):
  # Streaks: + for 1 and - for 0
  # Check streaks and divide
  if len(partial) < _gridSize:
   for _next in possibilities[len(partial)]:
    streak = [n(i, j) for i, j in zip(streak.copy(), _next)]
    if (all(i < 3 for i in streak)) and _next not in partial:
     yield from f(partial.copy() + [_next], streak.copy())
  else:
   # Already tested: no 3 same lines
   # no 3 same sign in a row/column
   # sum up to 0 in the line
   l = list(zip(*partial))
   # Each column is unique
   if len(set(l)) != len(l):
    return
   # Each column is correct
   for i in l:
    if not correctLine(''.join(i)):
     return
   if True:
    yield partial
 for i in f([], [0]*_gridSize):
  print(i)

